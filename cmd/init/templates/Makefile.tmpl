-include .env
export

PDF_FORGE_VERSION ?= main
PDF_FORGE_REPO    ?= https://github.com/rendis/pdf-forge.git
PDF_FORGE_TMP     := /tmp/pdf-forge-build
BASE_PATH         ?=

.DEFAULT_GOAL := help

# Auth: settings/app.yaml has no auth section = dummy auth (auto-login, no OIDC).
# To enable OIDC, uncomment the auth section in settings/app.yaml.

# Capture script name for run-script target
ifeq (run-script,$(firstword $(MAKECMDGOALS)))
  SCRIPT_NAME := $(wordlist 2,$(words $(MAKECMDGOALS)),$(MAKECMDGOALS))
  $(eval $(SCRIPT_NAME):;@:)
endif

# ── Development ─────────────────────────────────────────

run: .env           ## Run server (auto-embeds frontend if missing)
	@if [ ! -f frontend-dist/index.html ]; then \
		if command -v pnpm > /dev/null 2>&1; then \
			echo "Frontend not found. Building..."; \
			$(MAKE) embed-app; \
		else \
			echo "WARNING: Frontend not embedded. Install Node.js + pnpm then run: make embed-app"; \
		fi; \
	fi
	go run .

dev: .env           ## Hot reload (auto-embeds frontend if missing)
	@if [ ! -f frontend-dist/index.html ]; then \
		if command -v pnpm > /dev/null 2>&1; then \
			echo "Frontend not found. Building..."; \
			$(MAKE) embed-app; \
		else \
			echo "WARNING: Frontend not embedded. Install Node.js + pnpm then run: make embed-app"; \
		fi; \
	fi
	air

migrate:            ## Apply database migrations
	go run . migrate

# ── Build ────────────────────────────────────────────────

build:              ## Build production binary (API only)
	CGO_ENABLED=0 go build -o bin/server .

embed-app:          ## Clone pdf-forge frontend, build, and embed into frontend-dist/
	@command -v node > /dev/null 2>&1 || { echo "ERROR: Node.js is required. Install from https://nodejs.org"; exit 1; }
	@command -v pnpm > /dev/null 2>&1 || { echo "ERROR: pnpm is required. Install: npm install -g pnpm"; exit 1; }
	@echo "Cloning pdf-forge ($(PDF_FORGE_VERSION))..."
	@rm -rf $(PDF_FORGE_TMP)
	git clone --depth 1 --branch $(PDF_FORGE_VERSION) $(PDF_FORGE_REPO) $(PDF_FORGE_TMP)
	@echo "Installing dependencies..."
	pnpm --dir $(PDF_FORGE_TMP)/app install --frozen-lockfile
	@echo "Building frontend..."
	VITE_BASE_PATH=$(BASE_PATH) pnpm --dir $(PDF_FORGE_TMP)/app build
	@rm -rf frontend-dist/*
	@cp -r $(PDF_FORGE_TMP)/app/dist/* frontend-dist/
	@rm -rf $(PDF_FORGE_TMP)
	@echo "Frontend embedded in frontend-dist/"

test:               ## Run tests
	go test ./...

lint:               ## Run golangci-lint
	golangci-lint run

# ── Docker (full stack with frontend) ────────────────────

docker-up:          ## Start postgres + api (with embedded frontend)
	docker compose up --build

docker-down:        ## Stop all services
	docker compose down

# ── Utilities ────────────────────────────────────────────

doctor:             ## Check system dependencies
	@echo "=== pdf-forge doctor ==="
	@echo ""
	@printf "Go.............. " && go version > /dev/null 2>&1 && echo "ok" || echo "MISSING"
	@printf "Typst........... " && typst --version > /dev/null 2>&1 && echo "ok" || echo "MISSING"
	@printf "PostgreSQL...... " && pg_isready > /dev/null 2>&1 && echo "ok" || echo "not running"
	@printf "Node.js......... " && node --version > /dev/null 2>&1 && echo "ok" || echo "MISSING (needed for embed-app)"
	@printf "pnpm............ " && pnpm --version > /dev/null 2>&1 && echo "ok" || echo "MISSING (needed for embed-app)"
	@printf "Go build........ " && go build ./... > /dev/null 2>&1 && echo "ok" || echo "FAIL"
	@printf "Go modules...... " && go mod verify > /dev/null 2>&1 && echo "ok" || echo "FAIL"
	@echo ""
	@echo "Done."

clean:              ## Remove build artifacts
	rm -rf bin/ tmp/
	@rm -rf frontend-dist/*
	@touch frontend-dist/.gitkeep
	@rm -rf $(PDF_FORGE_TMP)

run-script:         ## Run a script (usage: make run-script [name])
ifdef SCRIPT_NAME
	@# Direct execution
	@if [ ! -d "scripts/$(SCRIPT_NAME)" ]; then echo "Error: script '$(SCRIPT_NAME)' not found"; exit 1; fi
	@if [ ! -f "scripts/$(SCRIPT_NAME)/Makefile" ]; then echo "Error: scripts/$(SCRIPT_NAME)/Makefile not found"; exit 1; fi
	$(MAKE) -C scripts/$(SCRIPT_NAME) run
else
	@# Interactive selector
	@if [ ! -d "scripts" ]; then echo "Error: no scripts/ directory"; exit 1; fi
	@printf 'package main\n' > run-script-tmp.go
	@printf 'import (\n\t"errors"\n\t"fmt"\n\t"os"\n\t"os/exec"\n\t"path/filepath"\n\t"github.com/charmbracelet/bubbles/key"\n\t"github.com/charmbracelet/huh"\n)\n' >> run-script-tmp.go
	@printf 'const quitOption = "__quit__"\n' >> run-script-tmp.go
	@printf 'func main() {\n' >> run-script-tmp.go
	@printf '\tscriptsDir := "scripts"\n' >> run-script-tmp.go
	@printf '\tentries, err := os.ReadDir(scriptsDir)\n' >> run-script-tmp.go
	@printf '\tif err != nil {\n\t\tfmt.Fprintf(os.Stderr, "Error reading scripts/: %%v\\n", err)\n\t\tos.Exit(1)\n\t}\n' >> run-script-tmp.go
	@printf '\tvar scripts []string\n' >> run-script-tmp.go
	@printf '\tfor _, e := range entries {\n' >> run-script-tmp.go
	@printf '\t\tif e.IsDir() {\n' >> run-script-tmp.go
	@printf '\t\t\tmakefile := filepath.Join(scriptsDir, e.Name(), "Makefile")\n' >> run-script-tmp.go
	@printf '\t\t\tif _, err := os.Stat(makefile); err == nil {\n' >> run-script-tmp.go
	@printf '\t\t\t\tscripts = append(scripts, e.Name())\n' >> run-script-tmp.go
	@printf '\t\t\t}\n\t\t}\n\t}\n' >> run-script-tmp.go
	@printf '\tif len(scripts) == 0 {\n\t\tfmt.Println("No scripts available")\n\t\treturn\n\t}\n' >> run-script-tmp.go
	@printf '\toptions := make([]huh.Option[string], len(scripts)+1)\n' >> run-script-tmp.go
	@printf '\tfor i, s := range scripts {\n\t\toptions[i] = huh.NewOption(s, s)\n\t}\n' >> run-script-tmp.go
	@printf '\toptions[len(scripts)] = huh.NewOption("Quit", quitOption)\n' >> run-script-tmp.go
	@printf '\tvar selected string\n' >> run-script-tmp.go
	@printf '\tkeymap := huh.NewDefaultKeyMap()\n' >> run-script-tmp.go
	@printf '\tkeymap.Quit = key.NewBinding(key.WithKeys("q", "esc", "ctrl+c"), key.WithHelp("q", "quit"))\n' >> run-script-tmp.go
	@printf '\tselectField := huh.NewSelect[string]().Title("Select script").Description("Press q to quit").Options(options...).Value(&selected)\n' >> run-script-tmp.go
	@printf '\tform := huh.NewForm(huh.NewGroup(selectField)).WithKeyMap(keymap)\n' >> run-script-tmp.go
	@printf '\terr = form.Run()\n' >> run-script-tmp.go
	@printf '\tif err != nil {\n' >> run-script-tmp.go
	@printf '\t\tif errors.Is(err, huh.ErrUserAborted) {\n\t\t\treturn\n\t\t}\n' >> run-script-tmp.go
	@printf '\t\tfmt.Fprintf(os.Stderr, "Error: %%v\\n", err)\n\t\tos.Exit(1)\n\t}\n' >> run-script-tmp.go
	@printf '\tif selected == quitOption {\n\t\treturn\n\t}\n' >> run-script-tmp.go
	@printf '\tscriptDir := filepath.Join(scriptsDir, selected)\n' >> run-script-tmp.go
	@printf '\tmakeCmd := exec.Command("make", "-C", scriptDir, "run")\n' >> run-script-tmp.go
	@printf '\tmakeCmd.Stdout = os.Stdout\n' >> run-script-tmp.go
	@printf '\tmakeCmd.Stderr = os.Stderr\n' >> run-script-tmp.go
	@printf '\tmakeCmd.Stdin = os.Stdin\n' >> run-script-tmp.go
	@printf '\tmakeCmd.Env = os.Environ()\n' >> run-script-tmp.go
	@printf '\tif err := makeCmd.Run(); err != nil {\n\t\tos.Exit(1)\n\t}\n' >> run-script-tmp.go
	@printf '}\n' >> run-script-tmp.go
	@go mod download github.com/charmbracelet/huh@latest github.com/charmbracelet/bubbles@latest 2>/dev/null || true
	@go run run-script-tmp.go
	@rm -f run-script-tmp.go
endif

# ── Internal ─────────────────────────────────────────────

.env:
	@cp .env.example .env
	@echo "Created .env from .env.example"

help:               ## Show this help
	@grep -E '^[a-zA-Z_-]+:.*?## .*$$' $(MAKEFILE_LIST) | awk 'BEGIN {FS = ":.*?## "}; {printf "  \033[36m%-15s\033[0m %s\n", $$1, $$2}'

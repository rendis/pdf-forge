// Code generated by pdfforge-cli init for project "{{.ProjectName}}".
// pdf-forge: https://github.com/rendis/pdf-forge

package main

import (
	"context"
	"log"
	"log/slog"

	"github.com/rendis/pdf-forge/sdk"
	"{{.ModuleName}}/extensions"
	"{{.ModuleName}}/extensions/injectors"
)

func main() {
	engine := sdk.New(
		sdk.WithConfigFile("config/app.yaml"),
		sdk.WithI18nFile("config/injectors.i18n.yaml"),
	)

	// Register extensions via helper functions (keeps main clean)
	registerInjectors(engine)
	registerMiddleware(engine)
	registerLifecycle(engine)

	// Set mapper (handles request parsing for render)
	engine.SetMapper(&extensions.ExampleMapper{})

	// Set init function (loads shared data before injectors)
	engine.SetInitFunc(extensions.ExampleInit())

	// Set workspace injectable provider (dynamic injectables per workspace)
	// Provider receives req.Locale - you handle i18n internally
	engine.SetWorkspaceInjectableProvider(&extensions.ExampleWorkspaceProvider{})

	// Auto-apply pending database migrations (idempotent)
	if err := engine.RunMigrations(); err != nil {
		log.Fatal("migrations: ", err)
	}

	if err := engine.Run(); err != nil {
		log.Fatal(err)
	}
}

// registerInjectors registers all custom injectors.
// Group related injectors together for clarity.
func registerInjectors(engine *sdk.Engine) {
	// Example injectors (one per ValueType) - replace with your own
	engine.RegisterInjector(&injectors.ExampleValueInjector{})
	engine.RegisterInjector(&injectors.ExampleNumberInjector{})
	engine.RegisterInjector(&injectors.ExampleBoolInjector{})
	engine.RegisterInjector(&injectors.ExampleTimeInjector{})
	engine.RegisterInjector(&injectors.ExampleImageInjector{})
	engine.RegisterInjector(&injectors.ExampleTableInjector{})
	engine.RegisterInjector(&injectors.ExampleListInjector{})
}

// registerMiddleware registers HTTP middleware.
// Global middleware runs on ALL routes (health, swagger, api, internal).
// API middleware runs on /api/v1/* routes only, AFTER authentication.
func registerMiddleware(engine *sdk.Engine) {
	// Global middleware (all routes)
	engine.UseMiddleware(extensions.RequestLoggerMiddleware())
	engine.UseMiddleware(extensions.CustomHeadersMiddleware())

	// API middleware (/api/v1/* only, after auth)
	engine.UseAPIMiddleware(extensions.TenantValidationMiddleware())
}

// registerLifecycle registers startup and shutdown hooks.
// Hooks are SYNCHRONOUS - for background processes, spawn a goroutine.
func registerLifecycle(engine *sdk.Engine) {
	// Example: background scheduler pattern
	// Uncomment and adapt for real schedulers/workers
	var schedulerCancel context.CancelFunc
	var schedulerDone chan struct{}

	engine.OnStart(func(ctx context.Context) error {
		slog.InfoContext(ctx, "running OnStart hook")

		// Example: start a background scheduler
		var schedulerCtx context.Context
		schedulerCtx, schedulerCancel = context.WithCancel(context.Background())
		schedulerDone = make(chan struct{})

		go func() {
			defer close(schedulerDone)
			// Replace with your scheduler:
			// myScheduler.Run(schedulerCtx)
			slog.InfoContext(schedulerCtx, "background process started (placeholder)")
			<-schedulerCtx.Done()
			slog.InfoContext(schedulerCtx, "background process stopped")
		}()

		return nil // Return immediately - scheduler runs in background
	})

	engine.OnShutdown(func(ctx context.Context) error {
		slog.InfoContext(ctx, "running OnShutdown hook")

		// Stop background scheduler gracefully
		if schedulerCancel != nil {
			schedulerCancel()
			<-schedulerDone // Wait for clean exit
		}

		return nil
	})
}
